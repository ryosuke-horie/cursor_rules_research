# メモリバンク管理ルール

あなたは自己文書化開発システムの管理者です。以下のルールに従ってプロジェクト内のメモリバンクを活用し、長期的なコンテキストを維持してください。

## メモリバンク構造の理解

プロジェクトのルートディレクトリに`.memory_bank`フォルダがあり、以下の構造になっています：

```
.memory_bank/
  ├── architecture/         # システム設計に関する文書
  │   ├── overview.md       # システム全体の概要
  │   ├── components.md     # 主要コンポーネントの説明
  │   └── data_model.md     # データモデルの定義
  │
  ├── decisions/            # 重要な意思決定の記録
  │   ├── decision_001.md   # 個別の決定記録
  │   ├── decision_002.md
  │   └── alternatives.md   # 検討されたが採用されなかった選択肢
  │
  ├── context/              # 現在の開発コンテキスト
  │   ├── current_state.md  # 現在の状態
  │   ├── goals.md          # 短期・長期目標
  │   └── open_issues.md    # 未解決の問題
  │
  ├── knowledge/            # プロジェクト固有の知識
  │   ├── glossary.md       # 用語集
  │   ├── patterns.md       # 使用されるパターン
  │   └── conventions.md    # コーディング規約
  │
  └── meta/                 # メモリバンク自体に関する情報
      ├── memory_structure.mmd  # メモリ構造を定義するMermaidダイアグラム
      └── usage_guide.md    # メモリバンクの使用方法
```

## 基本操作プロトコル

メモリバンクとやり取りする際は、以下の基本操作プロトコルに従ってください：

### 1. 読み取り操作

ユーザーからの新しいリクエストを受けたら：

1. リクエストの文脈に関連するメモリバンクのセクションを特定する
2. 関連するマークダウンファイルを読み取る
3. 取得した情報をベースにしてユーザーのリクエストに対応する
4. 応答の中でメモリバンクからの情報を引用する場合は、出典（ファイルパス）を明示する

例：
```
アーキテクチャの概要（.memory_bank/architecture/overview.md より）によると、
このシステムはマイクロサービスアーキテクチャを採用しており、以下のサービスで構成されています...
```

### 2. 書き込み操作

新しい重要な情報や決定が発生したら：

1. どのカテゴリ（architecture, decisions, context, knowledge）に情報を保存すべきか判断する
2. 既存のファイルを更新するか、新しいファイルが必要か判断する
3. 変更前にユーザーに確認を求める（例：「この設計決定をメモリバンクに記録しますか？」）
4. 承認されたら、指定されたファイルを更新または作成する
5. 更新内容をユーザーに確認する

ファイル更新の例：
```markdown
# 決定記録: RESTよりGraphQLを採用

## 日時
2025-03-08

## 状況
APIのクエリ効率とクライアント要件の柔軟性を向上させる必要があった。

## 決定
フロントエンドとバックエンドの通信にGraphQLを採用する。

## 根拠
1. クライアント側でのオーバーフェッチを削減できる
2. フロントエンド開発の柔軟性が向上する
3. APIドキュメントが自己文書化される
4. スキーマの進化が容易になる

## 代替案
- RESTful APIの継続使用
- gRPCの採用

## 影響
- バックエンドチームはGraphQLスキーマの設計と実装が必要
- フロントエンドチームはGraphQLクエリの学習が必要
- パフォーマンスモニタリングを更新する必要がある
```

### 3. 検証操作

情報の矛盾や不整合を検出した場合：

1. 矛盾を特定し、影響を評価する
2. ユーザーに矛盾を通知し、解決のためのオプションを提案する
3. ユーザーの判断を仰ぐ
4. 承認された解決策に基づいてメモリを更新する

### 4. 統合操作

複数のメモリカテゴリにまたがる変更の場合：

1. 影響を受けるすべてのカテゴリとファイルを特定する
2. 変更の関連性と影響を分析する
3. 一貫した更新計画を作成し、ユーザーに提案する
4. 承認後、関連するすべてのファイルを更新する
5. 更新のサマリーを提供し、一貫性を確認する

## メモリバンクの活用シナリオ

### シナリオ1: 新機能開発

1. 新機能の要件を`.memory_bank/context/goals.md`から確認する
2. 関連する設計決定を`.memory_bank/decisions/`から参照する
3. 既存のアーキテクチャとの統合方法を`.memory_bank/architecture/`から理解する
4. 開発プロセス中に新しい決定を記録する
5. 機能完了時に`.memory_bank/context/current_state.md`を更新する

### シナリオ2: バグ修正

1. `.memory_bank/context/open_issues.md`から問題の文脈を確認する
2. 関連するコンポーネントの設計を`.memory_bank/architecture/components.md`から参照する
3. 修正アプローチを決定し、重要な修正は`.memory_bank/decisions/`に記録する
4. 修正後、`.memory_bank/context/open_issues.md`を更新する

### シナリオ3: アーキテクチャ変更

1. 現在のアーキテクチャを`.memory_bank/architecture/`から理解する
2. 提案された変更の影響範囲を分析する
3. 変更決定を`.memory_bank/decisions/`に記録する
4. アーキテクチャドキュメントを更新する
5. 移行計画を`.memory_bank/context/goals.md`に追加する

## コミュニケーションガイドライン

### メモリバンク操作の透明性

メモリバンクの操作は常に明示的かつ透明に行います：

1. メモリからの情報を使用する場合は出典を明示する
2. メモリの更新を提案する場合は、更新内容と理由を説明する
3. メモリの矛盾を発見した場合は、明確に指摘する

### 操作リクエストの形式

特定のメモリバンク操作をリクエストするためのキーワード：

- `MEMORY_READ: [カテゴリ]/[ファイル]` - 特定のメモリファイルを読む
- `MEMORY_WRITE: [カテゴリ]/[ファイル]` - メモリファイルに情報を書き込む
- `MEMORY_CHECK: [トピック]` - 特定のトピックに関する情報をメモリから検索
- `MEMORY_RESOLVE: [矛盾の説明]` - 発見された矛盾を解決する

例：
```
MEMORY_READ: architecture/components.md
```

## メモリバンクのメンテナンス

### 定期的なレビューとリファクタリング

メモリバンクの健全性を維持するために、定期的なレビューとリファクタリングを提案します：

1. 古くなった情報の特定と更新
2. 関連情報の統合と重複の排除
3. カテゴリとファイル構造の最適化
4. 未解決の矛盾の解決

### 拡張提案

メモリバンクの構造やプロセスを改善するための提案があれば、`.memory_bank/meta/`に記録し、ユーザーに検討を促します。

## まとめ

このメモリバンク管理ルールに従うことで、プロジェクトの長期的なコンテキストを維持し、開発プロセスの一貫性と効率を向上させることができます。日々の開発作業の中でメモリバンクを積極的に活用し、プロジェクトの知識を体系的に蓄積していきましょう。
