# TypeScript プロジェクトルール

あなたは、TypeScriptプロジェクトの開発をサポートするAIアシスタントです。以下のルールに従って、コードの分析、生成、修正を行ってください。

## 型システム

- すべてのコードにTypeScriptを使用し、強力な型付けを適用する
- インターフェース（interface）を優先的に使用し、型（type）は複雑な型合成が必要な場合のみ使用する
- enumの使用を避け、代わりにユニオン型やconstオブジェクトを使用する：
  ```typescript
  // 推奨
  type Status = 'pending' | 'active' | 'completed';
  
  // または
  const StatusMap = {
    PENDING: 'pending',
    ACTIVE: 'active',
    COMPLETED: 'completed'
  } as const;
  type Status = typeof StatusMap[keyof typeof StatusMap];
  
  // 非推奨
  enum Status {
    PENDING,
    ACTIVE,
    COMPLETED
  }
  ```
- any型の使用を避け、unknownを必要に応じて使用する
- すべての関数に明示的な戻り値の型を指定する
- nullとundefinedを区別し、オプショナルなプロパティとの一貫した扱いを確保する

## コンポーネントとモジュール

- Reactコンポーネントには関数コンポーネントを使用し、ClassComponentは使用しない
- コンポーネントPropsにはインターフェースを使用する：
  ```typescript
  interface UserProfileProps {
    user: User;
    onUpdate?: (updatedUser: User) => void;
  }
  
  function UserProfile({ user, onUpdate }: UserProfileProps): JSX.Element {
    // ...
  }
  ```
- 純粋な関数には「function」キーワードを使用する
- ユーティリティとヘルパー関数は別のモジュールに抽出し、明確に名前付けする
- コンポーネントには名前付きエクスポートを使用する（デフォルトエクスポートは避ける）
- モジュールはTSモジュール解決ルールに沿って明示的にインポート/エクスポートする
- 循環依存を避けるため、明確な階層構造を維持する

## 状態管理とサイドエフェクト

- Reactコンポーネントでは、クラスコンポーネントよりもHooksを優先する
- 複雑な状態ロジックにはuseReducerを使用する
- コンポーネント間で共有する状態にはContextを使用する
- サイドエフェクトは明示的に分離し、useEffectの依存配列を適切に設定する
- 非同期ロジックには一貫したパターンを使用する（async/awaitを推奨）
- APIリクエストとデータフェッチングは専用のカスタムフックに抽出する

## コード構造とフォーマット

- 一貫したインデントとスペースを使用する（2スペースを推奨）
- 条件分岐が複雑になる場合は早期リターンを使用する
- 長い式や条件は中間変数に分割する
- 命名規則：
  - 変数とプロパティ: camelCase
  - クラスとインターフェース: PascalCase
  - 定数: UPPER_SNAKE_CASE（オブジェクトの場合はPascalCase）
  - 型パラメータ: T, U, V, または単一大文字プレフィックスを使用（例：TValue）
- JSDocコメントでパブリックAPIとコンポーネントを文書化する
- 単一責任の原則に従い、関数とコンポーネントを小さく保つ

## テストとエラー処理

- すべての主要機能とコンポーネントにはユニットテストを書く
- テストファイルは.test.tsまたは.spec.ts拡張子を使用する
- モックとテストヘルパーは別のフォルダに整理する
- エラー処理は包括的に行い、ユーザーフレンドリーなエラーメッセージを提供する
- try/catchブロックは適切に使用し、ログ記録と回復戦略を確保する
- カスタムエラークラスを使用して、アプリケーション固有のエラーを伝達する

## パフォーマンスの最適化

- 不要な再レンダリングを避けるためにメモ化（useMemo, useCallback, React.memo）を使用する
- パフォーマンスのボトルネックに対してのみ最適化を行い、常にプロファイリングに基づく
- 大きなリストや表の仮想化を検討する
- 適切なWebpackの設定で効率的なバンドルを確保する
- 強力な型付けを活用してコンパイル時にエラーを捕捉し、ランタイムオーバーヘッドを削減する

## アクセシビリティとインターナショナリゼーション

- すべてのUIコンポーネントはWCAG基準に従ってアクセシブルであること
- 意味的なHTML要素を使用し、適切なARIAロールを提供する
- キーボードナビゲーションとフォーカス管理を確保する
- すべてのテキストはインターナショナリゼーション（i18n）をサポートする
- テキストハードコーディングを避け、翻訳キーを使用する

## プロジェクト固有の規約

- 状態管理には[Redux/MobX/Recoil/Zustand]を使用する
- UIコンポーネントには[Material-UI/Chakra UI/Tailwind CSS]を使用する
- APIリクエストには[Axios/React Query/SWR]を使用する
- フォーム処理には[Formik/React Hook Form]を使用する
- スキーマ検証には[Zod/Yup/Joi]を使用する
- ルーティングには[React Router/Next.js]を使用する

## 開発ワークフロー

- 機能開発前に型と契約を定義する
- 小さな粒度で頻繁にコミットする
- プルリクエストには適切なテストと文書を含める
- コンポーネントを開発する前にインターフェース設計を行う
- 型の整合性を確保するため、頻繁にTypeScriptコンパイラを実行する
